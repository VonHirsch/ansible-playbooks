---
# tasks file for cmi


- name: Define status_dir
  ansible.builtin.command: echo "{{ lfs }}/sources/status"
  register: status_dir
  changed_when: false

- ansible.builtin.debug:
    msg: "Status directory is {{ status_dir.stdout }}."

- name: Define done
  ansible.builtin.command: echo "{{ status_dir.stdout }}/{{ cmi_step }}.done"
  register: done_file
  changed_when: false

- name: Check file exists - {{ done_file }}
  ansible.builtin.stat:
    path: "{{ status_dir.stdout }}/{{ cmi_step }}.done"
  register: done_file

- name: Build software
  when: done_file.stat.isreg is not defined
  block:

    - name: Extract {{ cmi_archive }}
      ansible.builtin.unarchive:
        src: "{{ lfs }}/sources/{{ cmi_archive }}"
        dest: '{{ lfs }}/sources'
        list_files: true
      register: unarchive

    - name: Define extract_dir
      ansible.builtin.command: echo "{{ lfs }}/sources/{{ unarchive.files[0] | regex_replace('/.*', '') }}"
      register: extract_dir
      changed_when: false

    - ansible.builtin.debug:
        msg: "Extract directory is {{ extract_dir.stdout }}."

    - name: Define build dir
      block:
        - name: Define dir
          ansible.builtin.command: echo "{{ extract_dir.stdout }}"
          register: build_path
          changed_when: false

        - ansible.builtin.debug:
            msg: "Build path is {{ build_path.stdout }}."

    - name: Define build dir for subdir
      when: cmi_build_in_build is true
      block:
        - name: Define dir
          ansible.builtin.command: echo "{{ extract_dir.stdout }}/build"
          register: build_path
          changed_when: false

        - ansible.builtin.debug:
            msg: "Build path is {{ build_path.stdout }}."

    - name: Run extra unarchive commands
      ansible.builtin.shell: |
        {{ cmi_unarchive_extra }}
      args:
        chdir: "{{ extract_dir.stdout }}"
      when: cmi_unarchive_extra is defined
      environment: "{{ proxy_env }}"
      register: unarchive_extra

    - ansible.builtin.debug:
        var: unarchive_extra
      when: cmi_unarchive_extra is defined

    - name: Handle build in subdirectory
      when: cmi_build_in_build is true
      block:
        - name: Create dir {{ build_path.stdout }}
          ansible.builtin.file:
            path: '{{ build_path.stdout }}'
            state: directory
            mode: '0755'

    - name: Execute configure - cmi_configure_command
      ansible.builtin.shell: |
        {{ cmi_configure_command }}
        if [ $? -eq 0 ]; then touch {{ status_dir.stdout }}/{{ cmi_step }}.configured; fi
      args:
        chdir: "{{ build_path.stdout }}"
        creates: "{{ status_dir.stdout }}/{{ cmi_step }}.configured"
      environment: "{{ proxy_env }}"
      register: cmi_config_result
      when: cmi_dont_configure is not defined

    - ansible.builtin.debug:
        var: cmi_config_result.stdout_lines
      when: cmi_dont_configure is not defined

    - name: Execute make - make -j {{ gcc.jobs }}
      ansible.builtin.shell: |
        make -j {{ gcc.jobs }}
        if [ $? -eq 0 ]; then touch {{ status_dir.stdout }}/{{ cmi_step }}.made; fi
      args:
        chdir: "{{ build_path.stdout }}"
        creates: "{{ status_dir.stdout }}/{{ cmi_step }}.made"
      environment: "{{ proxy_env }}"
      register: cmi_make_result
      when: cmi_dont_make is not defined

    - ansible.builtin.debug:
        var: cmi_make_result.stdout_lines
      when: cmi_dont_make is not defined

    - name: Execute make install - {{ cmi_make_install_cmd }}
      ansible.builtin.shell: |
        {{ cmi_make_install_cmd }}
        if [ $? -eq 0 ]; then touch {{ status_dir.stdout }}/{{ cmi_step }}.installed; fi
      args:
        chdir: "{{ build_path.stdout }}"
        creates: "{{ status_dir.stdout }}/{{ cmi_step }}.installed"
      environment: "{{ proxy_env }}"
      register: cmi_makeinstall_result
      when: cmi_dont_makeinstall is not defined

    - ansible.builtin.debug:
        var: cmi_makeinstall_result.stdout_lines
      when: cmi_dont_makeinstall is not defined

    - ansible.builtin.debug:
        var: cmi_postinstall
      when: cmi_postinstall is defined

    - name: Run postinstall commands - {{ cmi_postinstall }}
      ansible.builtin.shell: |
        {{ cmi_postinstall }}
        if [ $? -eq 0 ]; then touch {{ status_dir.stdout }}/{{ cmi_step }}.postinstalled; fi
      args:
        chdir: "{{ extract_dir.stdout }}"
        creates: "{{ status_dir.stdout }}/{{ cmi_step }}.postinstalled"
      when: cmi_postinstall is defined
      environment: "{{ proxy_env }}"
      register: cmi_postinstall_result

    - ansible.builtin.debug:
        var: cmi_postinstall_result.stdout_lines

    - name: Clean up build - remove directory {{ extract_dir.stdout }}
      ansible.builtin.file:
        path: "{{ extract_dir.stdout }}"
        state: absent
      when: cmi_dont_clean is not defined
      environment: "{{ proxy_env }}"
      register: cmi_cleanup_result

    - ansible.builtin.debug:
        var: cmi_cleanup_result.stdout_lines

    - name: Done - Create the file "{{ status_dir.stdout }}/{{ cmi_step }}.done"
      ansible.builtin.file:
        path: "{{ status_dir.stdout }}/{{ cmi_step }}.done"
        state: touch
        mode: '0644'
      environment: "{{ proxy_env }}"


...
